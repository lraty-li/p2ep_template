# 字体系统技术文档

## 概述

本文档详细说明了 Persona 2 EP 字体系统的工作原理，包括字符编码、字体图片生成和映射关系。

## 1. 字符编码系统

### 1.1 字符编码格式

游戏使用 `0xPPYX` 格式的字符编码：
- `P` = 页码（高8位，0-31）
- `Y` = Y坐标（中间4位，0-15）
- `X` = X坐标（低4位，0-15）

### 1.2 字符编码计算

字符编码值通过以下公式计算：

```
编码值 = X + 16 * (Y + 16 * 页码)
```

其中：
- `页码` = font.json 中的页码键（0, 1, 2, ...）
- `Y` = 在16x16网格中的行索引（0-15）
- `X` = 在16x16网格中的列索引（0-15）

### 1.3 字符编码范围

每个页码对应 256 个编码位置：
- 页码0：编码范围 `0x0000 - 0x00FF`（0-255）
- 页码1：编码范围 `0x0100 - 0x01FF`（256-511）
- 页码2：编码范围 `0x0200 - 0x02FF`（512-767）
- ...
- 页码31：编码范围 `0x1F00 - 0x1FFF`（7936-8191）

## 2. font.json 结构

### 2.1 文件格式

`font.json` 是一个 JSON 对象，结构如下：

```json
{
  "页码": [
    [16个字符],  // 第0行
    [16个字符],  // 第1行
    ...
    [16个字符]   // 第15行（共16行）
  ]
}
```

### 2.2 示例

```json
{
  "0": [
    [" ", "、", "。", ",", ".", "・", ":", ";", "?", "!", "゛", "゜", "´", "`", "¨", "^"],
    ["￣", "_", "ヽ", "ヾ", "ゝ", "ゞ", "〃", "仝", "々", "〆", "〇", "ー", "―", "-", "/", "\\"],
    ...
  ],
  "1": [
    ["", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o"],
    ...
  ]
}
```

### 2.3 空字符串处理

- 空字符串 `""` 表示该位置未被使用或未定义字符
- 渲染时会跳过空字符位置

## 3. 字体图片系统

### 3.1 图片规格

- **图片尺寸**：256x256 像素
- **字符网格**：16x16 网格
- **字符大小**：每个字符 16x16 像素
- **格式**：PNG，RGBA（透明背景）

### 3.2 字符布局

每个字体图片包含 256 个字符位置（16行 × 16列），字符按以下方式排列：

```
位置 (0,0)  位置 (1,0)  ...  位置 (15,0)
位置 (0,1)  位置 (1,1)  ...  位置 (15,1)
...
位置 (0,15) 位置 (1,15) ...  位置 (15,15)
```

### 3.3 页码与图片文件映射

- `font0.png` → 页码0 → `5.gim`
- `font1.png` → 页码1 → `6.gim`
- `font2.png` → 页码2 → `7.gim`
- ...
- `font31.png` → 页码31 → `36.gim`

**映射规则**：页码 P 对应 `(5+P).gim`

## 4. 字符高度

### 4.1 固定高度

**重要**：所有字符的高度都是固定的，不存储在 JSON 文件中。

### 4.2 高度值

在 `eboot/asm/vwf.js` 的 `mapTextureFix` 函数中，高度被硬编码为：

```javascript
lui(tmp, 0x4180); //height, 16.0
```

- **高度值**：16.0（浮点数）
- **十六进制**：`0x4180`
- **所有字符共享相同高度**

### 4.3 水平信息

`font_info.json` 只存储水平信息：
- `left`：左边距（像素）
- `width`：字符宽度（像素）

## 5. font0 和 font1 的关系

### 5.1 页码索引

`font.json` 中的 `"0"` 和 `"1"` 是**页码索引**，不是直接对应 `font0.png` 和 `font1.png`。

### 5.2 字符编码映射

- 页码0的字符：编码值 0-255，Y坐标 0-255
- 页码1的字符：编码值 256-511，Y坐标 256-511（通过代码中 `addiu(y, y, 256)` 实现）

### 5.3 渲染时的处理

在 `vwf.js` 的 `mapTextureFix` 函数中：
- 提取页码：`srl($t4, $v1, 8)`
- 当页码不为0时，Y坐标加256：`addiu(y, y, 256)`

这允许页码1的字符通过Y坐标偏移访问，可能：
- 被合并到同一个纹理图集中，或
- 游戏动态切换纹理

## 6. 字体图片生成

### 6.1 生成脚本

使用 `generate_font_images.py` 脚本从字体文件生成图片：

```bash
cd font
python generate_font_images.py
```

### 6.2 生成过程

1. 读取 `locale/font.json` 获取字符布局
2. 加载字体文件（如 `fusion-pixel-10px-monospaced-zh_hans.otf`）
3. 对每个页码：
   - 创建 256x256 像素的图片
   - 遍历 16x16 网格
   - 渲染每个字符到对应位置（16x16像素）
   - 字符居中显示
   - 跳过空字符位置
4. 保存为 `font{页码}.png`

### 6.3 字符渲染

- 字符颜色：白色（255, 255, 255）
- 背景：透明（0, 0, 0, 0）
- 字符在16x16格子中居中显示
- 如果字体不支持某个字符，该位置留空

## 7. files.json 配置

### 7.1 文件映射

`files.json` 定义了字体图片与游戏资源文件的映射关系：

```json
{
  "path": "/PSP_GAME/USRDIR/pack/P2PT_ALL.cpk$/syscg.bin$",
  "files": {
    "font0.png": [
      {
        "path": "5.gim$/image.png",
        "args": { "useSourcePalette": true, "matchPalette": true }
      }
    ],
    ...
  }
}
```

### 7.2 映射规则

- `font{页码}.png` → `{5+页码}.gim$/image.png`
- 例如：`font2.png` → `7.gim$/image.png`

## 8. 中文化注意事项

### 8.1 需要生成的图片

中文化需要生成页码2-31的字体图片（共30个文件），因为：
- 页码0-1：通常包含基本字符（英文、数字、标点）
- 页码2-31：包含中文字符和其他扩展字符

### 8.2 字符布局

确保 `font.json` 中正确配置了中文字符的位置，字符必须：
- 按照16x16网格排列
- 每个位置对应一个字符编码值
- 空位置使用空字符串 `""`

### 8.3 字体选择

选择合适的中文字体文件：
- 像素字体（如 `fusion-pixel-10px-monospaced-zh_hans.otf`）
- 16x16像素大小
- 支持所需的中文字符集

## 9. Event Encoding 和 Font Encoding 转换

### 9.1 两种编码系统

游戏使用两种字符编码系统：

1. **Event Encoding (estr)**：用于事件脚本中的文本存储
   - 存储在 `locale/event.json` 中
   - 格式：`{"编码值(十六进制)": "字符"}`
   - 例如：`{"0b6c": "，"}`

2. **Font Encoding (fstr)**：用于实际渲染的字体编码
   - 存储在 `locale/font.json` 中
   - 格式：`{"页码": [[16个字符], ...]}`
   - 通过页码、Y坐标、X坐标定位字符

### 9.2 event2fontMap 转换表

游戏使用 `event2fontMap` 转换表将 event encoding 转换为 font encoding：

- **位置**：`eboot/asm/locale.js`
- **原始限制**：`0x0b45` = 2885 个条目（原始游戏设计）
- **扩展限制**：`0x0c00` = 3072 个条目（当前实现）
- **有效范围**：event encoding 值 0 到 3071（0x0000 - 0x0bff）
- **每个条目**：2 字节（uint16_t），存储对应的 font encoding 值
- **内存占用**：3072 × 2 = 6144 字节（约 6 KB）

### 9.3 转换表生成

转换表通过以下逻辑生成（在 `eboot/asm/locale.js` 中）：

```javascript
for (let i = 0; i < 0x0c00; i++) {  // 当前扩展为 0x0c00 (3072)
  let v = locale.font.utf2bin[locale.event.bin2utf[i]];
  if (locale.event.bin2utf[i] === undefined) v = 0;
  if (v === undefined) {
    console.warn(`Unknown character mapping for ${i} ${locale.event.bin2utf[i]}`);
  }
  write_u16(v);  // 写入 font encoding 值
}
```

**注意**：原始游戏代码使用 `0x0b45` (2885)，当前实现已扩展为 `0x0c00` (3072) 以支持更多字符。

### 9.4 编码范围限制问题

**原始限制**：`event2fontMap` 的原始大小是 `0x0b45` (2885)，这意味着：

- ✅ **原始支持范围**：event encoding 值 0-2884（0x0000 - 0x0b44）
- ❌ **原始超出范围**：event encoding 值 ≥ 2885（0x0b45 及以上）

**当前扩展限制**：已扩展为 `0x0c00` (3072)：

- ✅ **当前支持范围**：event encoding 值 0-3071（0x0000 - 0x0bff）
- ❌ **当前超出范围**：event encoding 值 ≥ 3072（0x0c00 及以上）

**问题表现**：
- 当 event encoding 值超出限制时，访问 `event2fontMap` 会越界
- 越界访问可能读取到错误的内存数据
- 导致字符渲染错误（例如：`，` 被渲染成 `$`）

**实际影响（原始限制 0x0b45）**：
- 页码0的字符：编码 0-255 ✅ 安全
- 页码1的字符：编码 256-511 ✅ 安全
- 页码2的字符：编码 512-767 ⚠️ 部分安全（512-2884）
- 页码11的字符：编码 2816-3071 ⚠️ 部分超出（2816-2884 安全，2885-3071 超出）

**实际影响（扩展限制 0x0c00）**：
- 页码0-11的字符：编码 0-3071 ✅ 完全支持
- 页码12的字符：编码 3072-3327 ⚠️ 部分支持（3072-3327 超出）
- 页码13-31的字符：编码 3328-8191 ❌ 完全超出

### 9.5 解决方案：字符优先排序

为了确保常用字符（特别是中文标点）能正确渲染，需要将它们优先放在前 2 页：

**策略**：
1. 将常用字符（特别是中文标点）优先放在页码 0-1
2. 确保这些字符的编码值 < 512（前 2 页的范围）
3. 这样所有常用字符都在 `event2fontMap` 的安全范围内

**实现**：
在 `rebuild_font_json.py` 中使用 `prioritize_chars()` 函数：
- 定义常用字符列表（中文标点：`，`、`。`、`！`、`？`、`：`、`；`、`…`、`、`、`—` 等）
- 将这些字符优先排序到字符列表的前面
- 确保它们被分配到页码 0-1

**示例**：
- `，` 的编码从 0x0b6c (2924) → 移动到前 2 页，编码 < 512 ✅
- `。` 的编码从 0x00bd (189) → 已在安全范围 ✅
- `…` 的编码从 0x0071 (113) → 已在安全范围 ✅

### 9.6 event.json 和 font.json 的同步

`event.json` 应该从 `font.json` 完全生成，确保一致性：

1. **生成脚本**：`sync_event_json.py`
2. **生成逻辑**：
   - 遍历 `font.json` 的所有页码和位置
   - 对每个非空字符，计算编码值：`page_num * 256 + y * 16 + x`
   - 生成 `event.json`：`{"编码值(十六进制)": "字符"}`
3. **同步关系**：`event.json` 完全以 `font.json` 为准

**工作流程**：
```bash
# 1. 重建 font.json（优先排序常用字符）
python rebuild_font_json.py

# 2. 从 font.json 生成 event.json
python sync_event_json.py
```

### 9.7 检查字符编码范围

在生成字体文件后，应该检查所有实际使用的字符是否在安全范围内：

- **当前安全范围**：event encoding 值 0-3071（扩展后）
- **原始安全范围**：event encoding 值 0-2884（原始限制）
- **检查方法**：遍历文本文件，查找所有字符的编码值
- **超出范围的字符**：需要移动到前 2 页或进一步扩展 `event2fontMap`

### 9.8 扩展 event2fontMap 的限制

**扩展方法**：

修改 `eboot/asm/locale.js` 中的循环上限值：

```javascript
// 原始限制
for (let i = 0; i < 0x0b45; i++) {  // 2885 个条目

// 当前扩展
for (let i = 0; i < 0x0c00; i++) {  // 3072 个条目

// 进一步扩展（需要谨慎）
for (let i = 0; i < 0x1000; i++) {  // 4096 个条目（支持 16 页）
for (let i = 0; i < 0x2000; i++) {  // 8192 个条目（支持 32 页）
```

**扩展限制和注意事项**：

1. **内存占用**：
   - `0x0b45` (2885) = 5770 字节 ≈ 5.6 KB
   - `0x0c00` (3072) = 6144 字节 ≈ 6 KB
   - `0x1000` (4096) = 8192 字节 = 8 KB
   - `0x2000` (8192) = 16384 字节 = 16 KB

2. **内存地址**：
   - `event2fontMap` 起始地址：`0x8c7d56c`
   - 扩展后需要确保后续内存区域是安全的
   - 过大的扩展可能覆盖其他数据，导致内存访问错误

3. **推荐扩展值**：
   - **保守扩展**：`0x0c00` (3072) - 支持到页码 12，增加约 374 字节
   - **中等扩展**：`0x1000` (4096) - 支持到页码 16，增加约 2.3 KB
   - **完全扩展**：`0x2000` (8192) - 支持所有 32 页，增加约 10.6 KB（需要验证内存安全）

4. **扩展步骤**：
   1. 修改 `eboot/asm/locale.js` 中的循环上限
   2. 重新编译游戏二进制文件
   3. 测试所有字符是否正常渲染
   4. 如果出现内存访问错误，降低扩展值或检查内存布局

5. **替代方案**：
   - 如果扩展导致内存问题，使用字符优先排序方案
   - 将常用字符放在前 2 页（编码 < 512），确保在原始限制内

## 10. 总结

### 10.1 关键概念

1. **字符编码**：`编码值 = X + 16 * (Y + 16 * 页码)`
2. **页码映射**：页码 P → `(5+P).gim` → `font{P}.png`
3. **固定高度**：所有字符高度为 16.0（硬编码）
4. **水平信息**：存储在 `font_info.json`（left, width）
5. **图片规格**：256x256像素，16x16字符网格
6. **编码转换**：event encoding → `event2fontMap` → font encoding
7. **范围限制**：`event2fontMap` 原始限制为编码值 0-2884，当前扩展为 0-3071

### 10.2 工作流程

1. 编辑 `locale/font.json` 定义字符布局（优先排序常用字符）
2. 运行 `rebuild_font_json.py` 重建 font.json（确保常用字符在前 2 页）
3. 运行 `sync_event_json.py` 从 font.json 生成 event.json
4. 运行 `generate_font_images.py` 生成字体图片
5. 更新 `files.json` 添加图片映射
6. 生成 `font_info.json` 定义字符宽度信息（使用工具）
7. 检查所有实际使用的字符编码是否在安全范围内（当前：0-3071）
8. 打包资源文件

---

**文档版本**：2.1  
**最后更新**：2024

**更新内容**：
- 添加了扩展 `event2fontMap` 的详细说明（9.8 节）
- 更新了当前实现限制为 `0x0c00` (3072)
- 添加了内存占用和扩展注意事项
- 更新了常见问题部分

---

## 附录：常见问题

### Q: 为什么某些字符（如 `，`）被渲染成其他字符（如 `$`）？

**A**: 这是因为字符的 event encoding 值超出了 `event2fontMap` 的范围限制。在原始限制（2885）下，编码值 ≥ 2885 的字符会越界访问。当前已扩展为 3072，但如果字符编码 ≥ 3072，仍会出现问题。

**解决方案**：
1. **扩展限制**：修改 `eboot/asm/locale.js` 增加限制值（当前为 3072）
2. **字符优先排序**：将常用字符优先放在前 2 页，确保编码值 < 512（在原始限制内也安全）

### Q: 如何检查字符是否在安全范围内？

**A**: 检查字符的 event encoding 值是否在安全范围内：
- **当前扩展限制**：< 3072（0x0c00）
- **原始限制**：< 2885（0x0b45）

可以使用脚本遍历文本文件，查找所有字符的编码值，确认是否超出限制。

### Q: 能否扩展 `event2fontMap` 的大小？

**A**: 可以，但需要注意内存限制。当前实现已扩展为 `0x0c00` (3072)，支持编码值 0-3071。进一步扩展需要：
1. 修改 `eboot/asm/locale.js` 中的循环上限
2. 确保后续内存区域是安全的
3. 重新编译游戏二进制文件
4. 测试验证无内存访问错误

**扩展建议**：
- 保守扩展：`0x0c00` (3072) - 当前实现，安全
- 中等扩展：`0x1000` (4096) - 支持 16 页，需要验证
- 完全扩展：`0x2000` (8192) - 支持 32 页，需要仔细验证内存安全

**替代方案**：如果扩展导致问题，使用字符优先排序方案，将常用字符放在前 2 页。

